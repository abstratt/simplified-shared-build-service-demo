import org.gradle.api.services.BuildService
import org.gradle.api.services.BuildServiceParameters
import org.gradle.api.services.ServiceReference

def serviceProvider = gradle.sharedServices.registerIfAbsent("countingService", SubCountingService1) {
    parameters.initial = 42
}

gradle.sharedServices.registerIfAbsent("altCountingService", SubCountingService2) {
    parameters.initial = 100
}

abstract class LegacyServiceConsumingTask extends DefaultTask {
    @Internal
    abstract Property<BaseCountingService> getCounter()

    @TaskAction
    def go() {
        counter.get().increment()
    }
}

abstract class TaskUsingServiceReferenceByType extends DefaultTask {
    @ServiceReference
    abstract Property<SubCountingService1> getCounter()

    @TaskAction
    def go() {
        counter.get().increment()
    }
}

abstract class TaskUsingAmbiguousServiceReferenceType extends DefaultTask {
    @ServiceReference
    abstract Property<BaseCountingService> getCounter()

    @TaskAction
    def go() {
        counter.get().increment()
    }
}

abstract class TaskUsingNamedServiceReference extends DefaultTask {
    @ServiceReference("altCountingService")
    abstract Property<BaseCountingService> getCounter()

    @TaskAction
    def go() {
        counter.get().increment()
    }
}

// fails to declare service usage (gets warning)
tasks.register("counter0", LegacyServiceConsumingTask) {
    counter = serviceProvider
    doFirst {
        counter.get().increment()
    }
}

// declares usage using Task#usesService
tasks.register("counter1", LegacyServiceConsumingTask) {
    counter = serviceProvider
    usesService(serviceProvider)
    doFirst {
        counter.get().increment()
    }
}

// declares usage using @ServiceReference (matching by type)
tasks.register("counter2", TaskUsingServiceReferenceByType) {
    doFirst {
        counter.get().increment()
    }
}


// declares usage using @ServiceReference (by type) using an ambiguous type, which fails 
tasks.register("counter3", TaskUsingAmbiguousServiceReferenceType) {
    doFirst {
        counter.get().increment()
    }
}

// declares usage using @ServiceReference (by type) desimbiguating via explicit assignment
tasks.register("counter4", TaskUsingAmbiguousServiceReferenceType) {
    counter = serviceProvider
    doFirst {
        counter.get().increment()
    }
}

// declares usage using @ServiceReference (with a service name, which is free from ambiguity)
tasks.register("counter5", TaskUsingNamedServiceReference) {
    doFirst {
        counter.get().increment()
    }
}

interface CountingParams extends BuildServiceParameters {
    Property<Integer> getInitial()
}

abstract class BaseCountingService implements BuildService<CountingParams>, AutoCloseable {
    int value

    BaseCountingService() {
        value = parameters.initial.get()
        println("service: created with value = ${value}")
    }

    synchronized int getInitialValue() { return parameters.initial.get() }

    synchronized void reset() {
        value = parameters.initial.get()
        println("service: value is ${value}")
    }

    synchronized int increment() {
        value++
        println("service: value is ${value}")
        return value
    }

    @Override
    void close() {
        println("service: closed with value ${value}")
    }
}

abstract class SubCountingService1 extends BaseCountingService {}

abstract class SubCountingService2 extends BaseCountingService {}